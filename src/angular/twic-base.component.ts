/**
 * base component
 * Used in twic-img and twic-video
 */
import {
    Component,
    ElementRef,
    Input,
    OnDestroy,
    OnInit,
    ViewChild,
} from "@angular/core";

import type { Mode, Placeholder } from "../_/types";
import { computeData, computeStyle, computeWrapperClass, computeWrapperStyle } from "../_/compute";
import { createPlaceholderHandler, PlaceholderHandler } from "../_/placeholder";
import {
    parseBot,
    parseClassName,
    parseFocus,
    parseMode,
    parsePlaceholder,
    parsePosition,
    parseRatio,
    parseSrc,
    parseStep,
    parseTransition,
    parseTransitionDelay,
    parseTransitionDuration,
    parseTransitionTimingFunction,
} from "../_/parse";

@Component( {
    "selector": `lib-twic-base`,
    "template": `<p>To implement in child class</p>`,
} )
export class TwicBaseComponent implements OnInit, OnDestroy {

    @Input() alt: string = undefined;
    @Input() bot: string = undefined;
    @Input() className: string = undefined;
    /**
     * default value: none
     * specifies the focus point for transformations.
     * The value of this attribute must be none or, like in the focus API, valid coordinates or auto.
     */
    @Input() focus: string = undefined;
    @Input() mode: Mode = undefined;
    @Input() placeholder: Placeholder = undefined;
    @Input() position: string = undefined;
    @Input() ratio: number | string = undefined;
    @Input() src: string;
    /**
     * default value: none (any value that is not a number or none will be ignored)
     * Stepping will round the computed width of the media to the closest multiple step
     *
     */
    @Input() step: number = undefined;
    @Input() transition = true;
    @Input() transitionDelay: string = undefined;
    @Input() transitionDuration: string = undefined;
    @Input() transitionTimingFunction: string = undefined;
    /**
     * to access to the div generated by render method
     * <div #wrapper>...</div>
     * static set to true because we want access on ngOnInit
     */
    @ViewChild( `wrapper`, {
        "static": true,
    } ) wrapperElementRef!: ElementRef;
    /**
     * effective wrapper div element (this.wrapperElement.nativeElement)
     * Wrapper is the div element that contains (img or video) and 2 ghost div
     * On the latest ghost div, we will add an sizeObserver
     * SizeObserver will evaluate if background image should be resized
     * if ratio, mode, placeholder changes (see style-driven)
     * NB : lastest ghost div has a fixed height/width that does not change with screen resize
     * Height/width of latest ghost div depends on breakpoints
     */
    wrapper: HTMLDivElement;
    /**
     * wrapper management object
     */
    _p: PlaceholderHandler;
    /**
     * wrapper style
     * Allows background image management (mode, placeholder, position and background image ratio)
     */
    wrapperStyle: Record<string, string>;
    constructor() {
        this._p = createPlaceholderHandler();
    }
    /**
     * compute and return element's (img or video) attributes
     * attributes are recomputed on dom element modification (size or attributes)
     */
    getElementAttributes(): Record<string, string> {
        return {
            ...computeData(
                parseBot( this.bot ),
                parseFocus( this.focus ),
                parseSrc( this.src ),
                parseStep( this.step )
            ),
        };
    }
    /**
     * compute and return element's (img or video) style
     * style are recomputed on dom element modification (size or attributes)
     */
    getElementStyle(): Record<string, string> {
        return computeStyle(
            parseMode( this.mode ),
            parsePosition( this.position ),
            parseTransition( this.transition ),
            parseTransitionDelay( this.transitionDelay ),
            parseTransitionDuration( this.transitionDuration ),
            parseTransitionTimingFunction( this.transitionTimingFunction )
        );
    }
    /**
     * compute wrapper class
     */
    getWrapperClassName(): string {
        return computeWrapperClass( parseClassName( this.className ) );
    }
    /**
     * compute wrapper initial style and instance storage
     * we don't want to recompute wrapper style on dom modification
     * Recomputing is delegated to size observer attached to ghost div
     */
    initWrapperStyle(): void {
        this.wrapperStyle = computeWrapperStyle(
            parseFocus( this.focus ),
            parseMode( this.mode ),
            parsePlaceholder( this.placeholder ),
            parsePosition( this.position ),
            parseRatio( this.ratio ),
            parseSrc( this.src ),
            this._p.setData
        );
    }
    /**
     * wrapper management
     * compute initial style
     * add (size) observer on lastest ghost div
     */
    initWrapper(): void {
        // we now have access to the div generated by render method
        this.wrapper = this.wrapperElementRef ? this.wrapperElementRef.nativeElement : undefined;
        this.initWrapperStyle();
        // associate wrapper to placeHolderHandler
        // a size observer will be attached to the ghost div within wrapper
        this._p.setWrapper( this.wrapper );
    }
    /**
     * wrapper management (construct and add observer)
     */
    ngOnInit(): void {
        this.initWrapper();
    }
    /**
     * remove size observer on destroy
     */
    ngOnDestroy(): void {
        this._p.delete();
    }

}
